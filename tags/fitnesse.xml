<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Steve Tooke - fitnesse</title>
  <id>http://tooky.co.uk/</id>
  <link href="http://tooky.co.uk/tags/fitnesse/"/>
  <link href="http://tooky.co.uk/tags/fitnesse.xml" rel="self"/>
  <updated>2013-01-18T00:00:00Z</updated>
  <entry>
    <title>Cucumber and Full Stack Testing</title>
    <link rel="alternate" href="http://tooky.co.uk/cucumber-and-full-stack-testing/"/>
    <id>http://tooky.co.uk/cucumber-and-full-stack-testing/</id>
    <published>2013-01-18T00:00:00Z</published>
    <updated>2013-12-18T10:29:53+00:00</updated>
    <author>
      <name>Steve Tooke</name>
    </author>
    <content type="html">&lt;p&gt;There has been two similar questions asked on two different mailing lists I subscribe to (Corey Haines&amp;#39; &lt;a title="Build an app with Corey Haines" href="http://www.cleancoders.com/codecast/bawch-episode-1/show"&gt;BAWCH&lt;/a&gt; mailing list, and &lt;a href="http://rubyrogues.com/"&gt;Ruby Rogues&lt;/a&gt; Parley list). Both of these lists are private so I thought it would be worthwhile posting my answer here.&lt;/p&gt;

&lt;p&gt;Both of the questions were concerned with out-side-in development, full-stack integration testing, and how much of the application needs to be tested through the entire system.&lt;/p&gt;

&lt;p&gt;Firstly consider why we write &lt;a href="http://cukes.info/"&gt;cucumber&lt;/a&gt; scenarios (or &lt;a href="http://fitnesse.org/"&gt;fitnesse&lt;/a&gt; test cases). These tests are business facing acceptance tests. They are a medium through which we can engage with the business people on our team and to help us understand how the system should behave. They give us an opportunity to check &lt;em&gt;our&lt;/em&gt; understanding of what the system should do &amp;mdash; to check the &lt;em&gt;business&lt;/em&gt;&amp;#39;s understanding of what the system should do. We automate these tests to give the business confidence that the system behaves as expected.&lt;/p&gt;

&lt;p&gt;Full-stack, end-to-end, integration tests are there to give us confidence that the system fits together correctly, that we have all the different pieces in place, and they are able to talk to each other.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s very easy to conflate these two concerns. I have worked on many systems where the business facing acceptance tests were also the end-to-end integration tests. The test runs end up being slow, and the tests are cumbersome to work with.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ve been talking about this with &lt;a href="https://twitter.com/mattwynne"&gt;Matt Wynne&lt;/a&gt; and he drew the following diagram:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Business Facing Acceptance Tests vs End-To-End Tests" src="https://dl.dropboxusercontent.com/u/41915/tooky-images/business-facing-vs-end-to-end.png" /&gt;&lt;/p&gt;

&lt;p&gt;The circle on the left represents the tests that we would write in cucumber (or fitnesse). The circle on the right the tests which exercise the whole system end-to-end. In the centre we have the intersection &amp;mdash; our cucumber scenarios which we run end-to-end against the whole system.&lt;/p&gt;

&lt;p&gt;The key thing is that your business acceptance tests do not all have to drive the whole system end-to-end. We only a need a few scenarios to go end-to-end to give us the confidence the system as a whole is working. We can also write system tests, that aren&amp;#39;t part of the acceptance suite, to test specific integrations&lt;/p&gt;

&lt;p&gt;Try to write acceptance tests that directly drive the domain objects. Use these to accurately describe your application&amp;#39;s behaviour. Focus them on the behaviour by not having them integrate the UI and the database.&lt;/p&gt;
</content>
  </entry>
</feed>
